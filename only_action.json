{"0": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "1": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "2": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "3": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "4": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "5": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "6": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "7": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "8": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "9": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "10": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "11": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "12": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "13": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "14": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '-', '~', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '-', '~', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "15": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "16": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "17": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "18": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "19": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "20": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "21": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "22": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "23": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "24": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "25": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "26": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "27": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "28": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "29": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "30": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "31": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "32": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "33": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "34": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "35": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "36": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "37": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "38": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "39": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "40": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "41": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "42": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "43": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', '*', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', '*', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "44": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "45": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "46": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "47": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "48": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "49": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "50": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "51": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "52": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "53": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "54": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "55": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "56": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "57": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "58": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "59": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "60": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "61": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "62": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "63": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "64": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "65": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '~', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '~', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "66": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "67": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "68": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "69": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "70": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "71": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "72": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "73": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "74": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "75": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', '*', ' ', '*', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', '*', ' ', '*', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "76": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "77": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "78": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "79": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "80": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "81": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "82": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "83": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "84": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "85": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "86": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "87": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "88": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "89": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "90": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "91": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "92": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "93": {"code": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "94": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "95": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "96": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "97": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "98": {"code": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}, "99": {"code": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))", "code_prediction": "import numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 3), (3, 0), (0, -3), (-3, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))"}}
