{
    "0": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "1": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "2": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "3": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "4": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "5": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "6": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "7": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '|', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "8": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "9": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "10": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '|', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "11": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "12": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "13": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "14": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "15": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "16": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "17": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '|', '_', '|', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '|', '|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "18": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "19": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "20": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '^', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "21": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "22": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "23": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "24": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "25": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '@', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "26": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "27": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "28": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "29": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "30": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "31": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "32": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '|', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "33": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "34": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "35": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "36": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "37": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "38": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', 'O', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "39": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "40": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "41": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "42": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "43": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "44": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '@', '@', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "45": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "46": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "47": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "48": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "49": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "50": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "51": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "52": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "53": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "54": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "55": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '@', '.', '@', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "56": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '*', '*', '^', '*', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "57": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "58": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "59": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "60": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "61": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '@', '@', '@', '@', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "62": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|', '|', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|', '|', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "63": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "64": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "65": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "66": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "67": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "68": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '@', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "69": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "70": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "71": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "72": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "73": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "74": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "75": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "76": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "77": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "78": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "79": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "80": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '|', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "81": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "82": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', '~', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', '~', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "83": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '^', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '^', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "84": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', '^', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "85": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "86": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '@', '@', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "87": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "88": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "89": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "90": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', '*', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "91": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "92": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "93": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "94": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '|', '|', '|', '_', '|', '|'],\n    ['|', '|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "95": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "96": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', '~', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "97": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "98": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "99": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n"
}