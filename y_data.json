{
    "0": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "1": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "2": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "3": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "4": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "5": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "6": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "7": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "8": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "9": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "10": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '^', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '^', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "11": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "12": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '@', '@', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "13": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "14": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "15": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', '*', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "16": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '~', '~', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "17": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "18": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "19": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "20": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', '~', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "21": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "22": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '@', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "23": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "24": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "25": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "26": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "27": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "28": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "29": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "30": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '*', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "31": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', '~', '~', ' ', '~', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "32": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "33": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '^', '^', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '^', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "34": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "35": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "36": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "37": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "38": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "39": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "40": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "41": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "42": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '|', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '|', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '|', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "43": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "44": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "45": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '@', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "46": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "47": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', '~', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "48": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "49": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '|', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "50": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "51": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "52": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "53": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '|', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '|', '|', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "54": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "55": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "56": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "57": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "58": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "59": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "60": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "61": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "62": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "63": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "64": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "65": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '^', '^', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "66": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "67": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '|', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '|', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "68": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "69": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "70": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "71": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "72": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "73": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "74": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "75": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '|', '|', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '|', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "76": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "77": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '|', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "78": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '.', '@', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '@', '@', '@', '@', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "79": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "80": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "81": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "82": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "83": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "84": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "85": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '^', '*', '*', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "86": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "87": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "88": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "89": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "90": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '|', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "91": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '^', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "92": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "93": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "94": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "95": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "96": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "97": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "98": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "99": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "100": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '|', '|', '|', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "101": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~', '~', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "102": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '@', '@', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "103": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "104": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "105": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "106": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "107": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "108": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '_', '_', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '|', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '|', '_', '|', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "109": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "110": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "111": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "112": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "113": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "114": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "115": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '^', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "116": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "117": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "118": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "119": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "120": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '@', '.', '@', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "121": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "122": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '@', '@', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "123": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "124": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "125": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "126": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "127": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', '*', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "128": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "129": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "130": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "131": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "132": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "133": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "134": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "135": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "136": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "137": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "138": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "139": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '^', '^', '*', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '^', '^', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "140": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "141": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "142": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "143": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "144": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '|', '|', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "145": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "146": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "147": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "148": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "149": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "150": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "151": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "152": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '^', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "153": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "154": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "155": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "156": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "157": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "158": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "159": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "160": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "161": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '~', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "162": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "163": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "164": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "165": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "166": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "167": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "168": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '|', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "169": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '@', '@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "170": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "171": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "172": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "173": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', '~', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "174": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "175": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "176": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "177": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "178": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "179": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "180": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "181": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "182": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "183": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '|', '_', '_', '|', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "184": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "185": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "186": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "187": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "188": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "189": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '|', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '|', '|', '|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "190": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "191": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "192": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "193": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '_', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '|', '|', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "194": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "195": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "196": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "197": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "198": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '@', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "199": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "200": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "201": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "202": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "203": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "204": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "205": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "206": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "207": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "208": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "209": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "210": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "211": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "212": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "213": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '@', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "214": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '|', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "215": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "216": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "217": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "218": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "219": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "220": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "221": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "222": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "223": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "224": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "225": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "226": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '^', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "227": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "228": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "229": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "230": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "231": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '|', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "232": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "233": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "234": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "235": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "236": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "237": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|', '|'],\n    ['|', '_', '|', '|', '_', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '|', '_', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "238": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "239": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "240": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "241": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', '~', '~', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "242": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "243": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "244": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "245": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', '~', ' ', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "246": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "247": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "248": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "249": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "250": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "251": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "252": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "253": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '^', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "254": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '-', '~', '~', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "255": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "256": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '@', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "257": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "258": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "259": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '|', '|', '_', '|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '|', '|', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "260": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "261": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "262": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "263": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "264": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "265": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "266": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "267": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "268": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "269": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "270": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "271": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "272": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "273": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "274": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '|', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "275": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "276": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '@', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "277": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "278": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "279": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "280": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "281": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '~', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "282": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "283": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "284": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "285": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "286": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "287": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '-', '-', '~', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "288": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "289": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "290": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "291": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "292": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "293": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "294": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "295": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "296": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '~', '~', '~', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "297": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "298": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "299": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '|', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '|', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "300": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "301": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "302": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '^', '^', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "303": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "304": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', '~', ' ', '~', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "305": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '^', '^', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "306": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "307": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '^', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "308": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '|', '|', '|', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '|', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "309": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "310": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "311": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "312": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "313": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', '~', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "314": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "315": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "316": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "317": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '^', '^', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "318": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "319": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "320": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "321": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "322": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "323": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', '~', '~', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "324": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "325": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "326": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "327": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "328": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "329": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "330": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "331": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "332": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "333": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "334": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "335": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "336": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "337": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '@', '@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "338": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "339": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "340": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "341": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "342": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "343": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "344": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "345": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "346": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "347": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '@', '@', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "348": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "349": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "350": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "351": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "352": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "353": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "354": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "355": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '^', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "356": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "357": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '^', '^', '*', '*', '^', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "358": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "359": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "360": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "361": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "362": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '|', '_', '_', '|', '_', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '|', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "363": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "364": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "365": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "366": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "367": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '.', '@', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "368": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "369": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "370": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "371": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '@', '.', '@', '@', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '@', '@', '.', '.', '.', '@'],\n    ['@', '@', '@', '@', '@', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "372": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '~', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '~', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "373": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "374": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '^', '*', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '^', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "375": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "376": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "377": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "378": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "379": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "380": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "381": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "382": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "383": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "384": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "385": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "386": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "387": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "388": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "389": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "390": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "391": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "392": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "393": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "394": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "395": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', '*', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', '*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "396": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "397": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "398": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "399": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "400": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "401": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '~', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "402": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "403": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', '~', ' ', '~', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "404": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "405": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "406": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "407": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "408": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "409": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "410": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '.', '.', '.', '@', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '@', '.', '@', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "411": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "412": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "413": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "414": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "415": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "416": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '^', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "417": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "418": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "419": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "420": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "421": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "422": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "423": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "424": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "425": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "426": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "427": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "428": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "429": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "430": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "431": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "432": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "433": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "434": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "435": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "436": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "437": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "438": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "439": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "440": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '~', '~', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "441": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', '~', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "442": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "443": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "444": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "445": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "446": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "447": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "448": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "449": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "450": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "451": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "452": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', '~', '~', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "453": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '^', '^', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "454": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "455": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "456": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "457": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "458": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "459": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', '*', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "460": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "461": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "462": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "463": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', '~', '~', ' ', '~', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "464": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "465": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "466": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "467": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "468": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "469": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "470": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '|', '_', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "471": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "472": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '^', '*', '*', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '^', '*', '^', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "473": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', '~', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "474": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "475": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "476": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "477": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "478": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "479": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "480": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "481": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "482": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "483": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "484": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "485": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '|', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "486": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "487": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "488": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "489": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "490": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "491": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "492": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '^', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "493": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '^', '^', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "494": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "495": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "496": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "497": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '@', '@', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "498": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "499": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "500": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "501": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "502": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "503": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '|', '_', '|', '|'],\n    ['|', '|', '_', '|', '|', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "504": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "505": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', '~', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "506": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "507": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', '~', ' ', ' ', '~', '~', '~', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "508": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "509": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "510": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "511": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "512": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "513": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "514": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "515": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "516": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "517": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '|', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "518": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "519": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "520": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', '~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "521": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "522": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "523": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "524": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "525": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "526": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "527": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "528": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "529": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "530": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "531": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '.', '.', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '@', '.', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "532": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '^', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "533": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "534": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "535": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "536": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "537": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "538": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "539": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '~', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "540": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "541": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "542": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "543": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "544": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "545": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "546": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "547": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "548": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "549": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "550": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "551": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "552": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "553": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '^', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "554": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '^', '*', '^', '^', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "555": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "556": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "557": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "558": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "559": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|', '|'],\n    ['|', '|', '_', '_', '|', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "560": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "561": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '~', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '~', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "562": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "563": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|', '|', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '|', '_', '|', '|', '|', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "564": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', '~', ' ', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "565": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "566": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '^', '^', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '^', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "567": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "568": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "569": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '~', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "570": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', '~', ' ', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "571": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '~', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "572": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "573": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '-', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "574": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "575": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '|', '|', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '|', '|', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "576": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "577": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "578": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "579": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '~', '~', '~', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "580": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '|', '|', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '|', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "581": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "582": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "583": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "584": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "585": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "586": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "587": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "588": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "589": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "590": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "591": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "592": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "593": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "594": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "595": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "596": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "597": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "598": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '|', '_', '|', '_', '_', '_', '|', '_', '|', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "599": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', '~', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "600": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "601": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "602": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "603": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "604": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "605": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "606": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "607": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "608": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '|', '|', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '|', '|', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '|', '_', '|', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "609": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "610": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "611": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '@', '@', '.', '@', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "612": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "613": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '@', '.', '@', '@', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '@', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "614": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '|', '|', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "615": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "616": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "617": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "618": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "619": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '@', '.', '.', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '@', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "620": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "621": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "622": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "623": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "624": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', '~', '~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "625": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '.', '.', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '@', '@', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '@', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "626": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "627": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "628": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', '~', ' ', '~', '~', '~', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "629": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "630": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '~', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "631": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '~', '~', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '~', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "632": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "633": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "634": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '@', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "635": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "636": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "637": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "638": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '|', '_', '|', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "639": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '^', '^', '^', '*', '*', '^', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "640": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "641": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "642": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "643": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "644": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '@', '@', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "645": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "646": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "647": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "648": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "649": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '~', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "650": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '|', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "651": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "652": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '@', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "653": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "654": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "655": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '~', '~', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "656": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '^', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "657": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "658": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "659": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "660": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', '~', '~', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "661": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "662": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '@', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "663": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "664": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '^', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "665": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "666": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '|', '_', '|', '|', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "667": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "668": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "669": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "670": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', '~', '~', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', '~', '~', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "671": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "672": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "673": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "674": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '|', '|'],\n    ['|', '|', '|', '|', '_', '_', '_', '|', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "675": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "676": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "677": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "678": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "679": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "680": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "681": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "682": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "683": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "684": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "685": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "686": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "687": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "688": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "689": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "690": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "691": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "692": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "693": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '~', '~', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~', '~', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "694": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "695": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "696": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "697": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "698": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "699": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "700": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "701": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "702": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "703": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', '~', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', '~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "704": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "705": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "706": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "707": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "708": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "709": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|', '|', '|'],\n    ['|', '|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '|', '|', '|', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "710": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "711": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "712": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', '*', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "713": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "714": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "715": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "716": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "717": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "718": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', 'O', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "719": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "720": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "721": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', 'O', 'O', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "722": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "723": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "724": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '@', '@', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "725": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '^', '*', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "726": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '^', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '^', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "727": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "728": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "729": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "730": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '|', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "731": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "732": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "733": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "734": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "735": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "736": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '|', '|', '_', '_', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "737": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "738": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "739": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "740": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "741": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "742": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "743": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "744": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '^', '^', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "745": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "746": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "747": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '|', '|', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "748": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '|', '|', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '|', '|', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "749": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '@', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "750": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "751": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "752": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "753": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "754": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "755": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '@', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '@', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "756": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "757": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|', '|', '|'],\n    ['|', '_', '|', '|', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '|', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '_', '|', '_', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "758": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "759": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "760": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '^', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "761": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "762": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "763": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "764": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "765": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "766": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '@', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '@', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "767": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "768": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "769": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '|', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "770": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "771": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "772": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '^', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "773": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "774": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "775": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "776": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "777": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "778": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "779": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "780": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', '~', '~', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "781": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "782": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "783": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "784": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "785": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '@', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "786": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "787": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', '~', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', '~', '~', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "788": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "789": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "790": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "791": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "792": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "793": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "794": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "795": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "796": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "797": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "798": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "799": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "800": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '|', '|', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '_', '|', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "801": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "802": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "803": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '|', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "804": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '|', '_', '|', '_', '|', '|', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "805": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '@', '.', '@', '@', '@'],\n    ['@', '@', '@', '.', '.', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "806": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "807": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "808": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "809": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "810": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "811": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "812": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "813": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "814": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '@', '@', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "815": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "816": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '@', '@', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "817": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "818": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~', '~', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '~', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "819": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '@', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "820": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "821": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "822": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '~', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "823": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "824": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "825": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "826": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '@', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '@', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '@', '@', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "827": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "828": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', '~', ' ', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "829": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '|', '|', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "830": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "831": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "832": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "833": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "834": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', '~', '~', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', '~', ' ', '~', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "835": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "836": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "837": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "838": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "839": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "840": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "841": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '~', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "842": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "843": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', ' ', '~', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "844": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '_', '_', '|', '_', '|', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '|', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "845": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "846": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '^', '^', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "847": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "848": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "849": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "850": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "851": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "852": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', 'O', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "853": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '~', '-', '~', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "854": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "855": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "856": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "857": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "858": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '^', '*', '^', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '^', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "859": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "860": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "861": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '^', '^', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "862": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "863": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "864": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "865": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "866": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', '*', ' ', '*', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "867": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "868": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "869": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "870": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "871": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '-', '-', '~', '~', '-', '~', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '-', '-', '-', '-', '-', '-', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "872": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '~', '~', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "873": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '@', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "874": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '~', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "875": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "876": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '~', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '~', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "877": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "878": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "879": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '^', '*', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "880": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "881": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "882": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "883": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '@', '@', '.', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "884": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "885": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "886": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', '*', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "887": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "888": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '@', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '@', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "889": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "890": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '^', '^', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "891": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '^', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '^', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "892": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "893": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '@', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "894": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '^', '^', '^', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "895": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "896": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '|', '|', '|'],\n    ['|', '|', '_', '|', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "897": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '@', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "898": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '@', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '@', '.', '@', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "899": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "900": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', ' ', '*', '*', '*', '*', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "901": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "902": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', '~', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "903": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', '~', '~', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "904": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "905": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', 'O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', 'O', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "906": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '|', '|', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "907": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "908": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', 'O', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "909": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "910": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '^', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "911": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '~', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '~', '-', '~', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '~', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "912": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '^', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "913": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "914": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '_', '|', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "915": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '|', '|', '_', '|', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "916": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', '~', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "917": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "918": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "919": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', 'O', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "920": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', '*', ' ', '*', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "921": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '^', '^', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "922": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '|', '_', '|', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "923": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "924": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "925": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "926": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "927": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "928": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "929": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', '~', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "930": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "931": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "932": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "933": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '~', '~', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '~', '-', '~', '-', '~', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '~', '-', '~', '-', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '~', '-', '~', '-', '~', '-', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "934": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '|', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '|', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '|', '|', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "935": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '|', '_', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '|', '_', '|', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "936": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '@', '@', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '@', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "937": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '~', '~', '-', '~', '~', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "938": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', '~', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "939": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "940": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '@', '@', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '@', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "941": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "942": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "943": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '~', '-', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '~', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "944": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '|', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '|', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "945": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '^', '^', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "946": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '*', '^', '*', '*', '*', '^', '^', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '^', '*', '*', '^', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '^', '*', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '^', '^', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '*', '^', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "947": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '@', '@', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '.', '@', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "948": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '|', '_', '|', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '|', '|', '|', '|', '|'],\n    ['|', '_', '_', '_', '_', '|', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "949": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '@', '@', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '@', '.', '@', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "950": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "951": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', '*', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "952": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "953": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "954": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', '*', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "955": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "956": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', '*', '*', '*', ' ', '*', ' ', '*', '*', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "957": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '-', '~', '-', '~', '-', '~'],\n    ['~', '-', '~', '~', '~', '~', '-', '~', '-', '-', '~'],\n    ['~', '-', '~', '-', '-', '-', '~', '~', '-', '~', '~'],\n    ['~', '~', '-', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '~', '~'],\n    ['~', '~', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "958": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "959": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '-', '-', '-', '~', '-', '~', '-', '-', '~', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '~', '-', '~'],\n    ['~', '-', '~', '-', '~', '~', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '~', '~', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '-', '-', '-', '-', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "960": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '|', '|', '|', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|', '_', '|', '|', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "961": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "962": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "963": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', '*', '*', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "964": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "965": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "966": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', '*', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', '*', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "967": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '@', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '@', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "968": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '|', '_', '|', '|', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '|', '_', '_', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '|', '_', '|', '|'],\n    ['|', '_', '_', '|', '_', '|', '|', '_', '_', '_', '_', '_', '|'],\n    ['|', '_', '_', '|', '|', '_', '_', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "969": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '@', '.', '@', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '@', '@', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '@', '@', '.', '.', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "970": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '_', '_', '_', '_', '|', '_', '_', '|', '_', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '_', '_', '|', '|', '|'],\n    ['|', '|', '|', '_', '_', '_', '_', '_', '|', '|', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '|', '_', '_', '_', '_', '|', '_', '|'],\n    ['|', '|', '_', '_', '|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '_', '_', '_', '_', '_', '_', '_', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '|', '|', '_', '|', '_', '_', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '_', '|', '|', '|', '_', '|'],\n    ['|', '_', '|', '_', '_', '_', '|', '|', '|', '_', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "971": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', '~', ' ', '~', '~', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', '~', '~', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "972": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '^', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '^', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '^', '^', '^', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "973": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*'],\n    ['*', '*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "974": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '@', '@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '@', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '@', '.', '.', '.', '.', '@', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '@', '.', '@', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "975": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', '*', '*', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', '*', '*', '*', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "976": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'D', '~', '~', '-', '-', '-', '~', '~', '-', '-', '~', '~'],\n    ['~', '~', '~', '-', '-', '-', '~', '-', '-', '-', '-', '~', '~'],\n    ['~', '~', '-', '~', '-', '-', '~', '-', '-', '-', '~', '~', '~'],\n    ['~', '-', '-', '-', '~', '-', '-', '-', '-', '-', '-', '-', '~'],\n    ['~', '-', '-', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '-', '~', '-', '-', '-', '-', '-', '~'],\n    ['~', '~', '-', '-', '-', '-', '-', '~', '~', '-', '-', '-', '~'],\n    ['~', '~', '~', '-', '-', '-', '-', '-', '-', '~', '-', '-', '~'],\n    ['~', '-', '-', '-', '~', '~', '~', '-', '-', '-', '-', 'C', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'C':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "977": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', 'O', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "978": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '^'],\n    ['^', '*', '*', '^', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "979": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', '*', ' ', '*', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', '*', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "980": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "981": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '*', '^', '*', '*', '^', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '^', '*', '*', '*', '*', '*', '^'],\n    ['^', '^', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '*', '^', '*', '*', '^'],\n    ['^', '*', '^', '*', '*', '*', '*', '*', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "982": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', '~', ' ', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', '~', '~', ' ', '~', ' ', ' ', '~', '~', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', '~', '~', '~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "983": "\nimport numpy as np\n\nmaze=[\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n    ['|', 'N', '_', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '|', '_', '_', '|', '|'],\n    ['|', '_', '_', '_', '_', '_', '_', '_', '|'],\n    ['|', '|', '|', '|', '_', '_', '_', '_', '|'],\n    ['|', '_', '|', '_', '_', '|', '_', 'S', '|'],\n    ['|', '|', '|', '|', '|', '|', '|', '|', '|'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '|'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'S':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '|':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "984": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "985": "\nimport numpy as np\n\nmaze=[\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n    ['~', 'P', ' ', ' ', '~', '~', ' ', ' ', ' ', '~', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', '~', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', '~', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', '~', '~', ' ', '~', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~'],\n    ['~', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', '~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '~', ' ', '~'],\n    ['~', '~', ' ', '~', ' ', '~', ' ', ' ', ' ', ' ', ' ', '~', '~'],\n    ['~', '~', ' ', ' ', ' ', '~', ' ', ' ', ' ', '~', ' ', ' ', '~'],\n    ['~', ' ', ' ', ' ', '~', '~', ' ', ' ', ' ', ' ', ' ', 'X', '~'],\n    ['~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~', '~'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '~'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'X':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '~':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "986": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', 'O', '.', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "987": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', 'O', '.', '.', '.', 'O', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', 'O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', 'O', '.', 'O', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "988": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', '.', 'O', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "989": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', 'O', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', 'O', 'O', 'O', '.', 'O', '.', '.', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "990": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '@', '.', '@', '.', '.', '@', '.', '@'],\n    ['@', '.', '@', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '@', '.', '@', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '@', '@', '.', '@', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "991": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', 'O', '.', '.', 'O', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', 'O', '.', 'O', '.', '.', 'O'],\n    ['O', 'O', '.', 'O', '.', 'O', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', 'O', 'O', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', 'O', '.', '.', 'O', '.', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "992": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', '*', ' ', ' ', ' ', ' ', '*', '*', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', ' ', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "993": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'L', '.', '.', 'O', '.', '.', 'O', '.', '.', 'O', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'O', 'O', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', 'O', '.', 'O', '.', '.', '.', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', 'O', 'O', '.', 'O', '.', 'O', '.', '.', 'O', '.', 'O', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', 'O', 'O', '.', '.', 'O', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', '.', '.', 'O', '.', '.', '.', 'O'],\n    ['O', '.', 'O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', 'O', '.', '.', '.', '.', 'O', '.', '.', '.', 'B', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'B':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "994": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '^', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '^', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '^', '*', '*', '*', '*', '^', '^', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '*', '*', '*', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '^', '*', '*', '*', '^', '*', '^'],\n    ['^', '^', '*', '*', '^', '^', '*', '*', '*', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '^', '^', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "995": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '@', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '@', '@', '.', '@', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '@', '.', '.', '@', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "996": "\nimport numpy as np\n\nmaze=[\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n    ['*', 'E', ' ', '*', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', ' ', '*', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', '*', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*'],\n    ['*', '*', ' ', ' ', ' ', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', '*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', '*', ' ', '*'],\n    ['*', '*', ' ', ' ', ' ', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*'],\n    ['*', ' ', '*', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '*', '*', 'T', '*'],\n    ['*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '*'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'T':\n                    V[i][j] = 5\n                    continue\n                if maze[i][j] == '*':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "997": "\nimport numpy as np\n\nmaze=[\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n    ['O', 'R', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', 'O', '.', '.', '.', '.', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', 'O', 'O', '.', '.', '.', '.', '.', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', '.', 'O', 'O', 'O', 'O'],\n    ['O', '.', '.', '.', '.', '.', '.', 'O', 'O', '.', 'O', 'O'],\n    ['O', 'O', '.', '.', '.', '.', 'O', 'O', '.', '.', 'O', 'O'],\n    ['O', '.', '.', '.', '.', 'O', 'O', 'O', '.', '.', 'P', 'O'],\n    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != 'O'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'P':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == 'O':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "998": "\nimport numpy as np\n\nmaze=[\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n    ['@', 'T', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '@', '.', '@', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '@', '.', '.', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '.', '@', '@', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '@', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '@', '@'],\n    ['@', '.', '@', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '@', '.', '@', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '.', '.', '.', '.', '@'],\n    ['@', '.', '.', '.', '.', '@', '.', '.', '.', '@'],\n    ['@', '@', '.', '.', '.', '.', '@', '.', 'O', '@'],\n    ['@', '@', '@', '@', '@', '@', '@', '@', '@', '@'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '@'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'O':\n                    V[i][j] = 2\n                    continue\n                if maze[i][j] == '@':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n",
    "999": "\nimport numpy as np\n\nmaze=[\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n    ['^', 'S', '*', '^', '*', '^', '*', '*', '*', '*', '*', '*', '^', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '^', '*', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '*', '*', '*', '*', '*', '*', '*', '*', '*', '^'],\n    ['^', '*', '*', '*', '^', '*', '*', '*', '*', '*', '*', '^', '*', '^'],\n    ['^', '*', '*', '^', '*', '*', '*', '*', '^', '^', '*', '*', '*', '^'],\n    ['^', '*', '^', '^', '^', '*', '*', '^', '^', '^', '^', '*', '*', '^'],\n    ['^', '*', '*', '*', '*', '*', '*', '^', '*', '^', '*', '^', '*', '^'],\n    ['^', '^', '^', '*', '^', '*', '*', '*', '^', '*', '*', '^', 'H', '^'],\n    ['^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^', '^'],\n]\n\ndef value_iteration(maze, gamma=0.9):\n    rows = len(maze)\n    cols = len(maze[0])\n    \n    # Initialize the value function\n    V = np.zeros((rows, cols))\n    \n    # Define actions:\n    actions = [(0, 1), (1, 0), (0, -1), (-1, 0), (0, 2), (2, 0), (0, -2), (-2, 0)]\n    \n    # Helper function to check if a cell is valid to move into\n    def is_valid_move(x, y):\n        return 0 <= x < rows and 0 <= y < cols and maze[x][y] != '^'\n    \n    # Perform value iteration\n    for i in range(1000):\n        for i in range(rows):\n            for j in range(cols):\n                if maze[i][j] == 'H':\n                    V[i][j] = 3\n                    continue\n                if maze[i][j] == '^':\n                    continue  # Walls or obstacles have no value\n                \n                max_value = float('-inf')\n                for action in actions:\n                    new_i, new_j = i + action[0], j + action[1]\n                    if is_valid_move(new_i, new_j):\n                        max_value = max(max_value, V[new_i][new_j])\n                V[i][j] = gamma * max_value\n    \n    return V\n\nnp.set_printoptions(precision=2)\nprint(value_iteration(maze))\n"
}